esphome:
  name: esp32-p4-satellite
  friendly_name: "ESP32-P4 Voice Satellite"
  project:
    name: "waveshare.esp32_p4_mic_ha"
    version: "2.0"
  platformio_options:
    board_build.flash_mode: dio
  on_boot:
    - priority: -200
      then:
        - switch.turn_on: amp_enable
        - delay: 200ms
        - audio_dac.set_volume:
            id: es8311_dac
            volume: 85%

esp32:
  board: esp32-p4-evboard
  variant: esp32p4
  flash_size: 16MB
  framework:
    type: esp-idf
    advanced:
      enable_idf_experimental_features: yes

logger:
  hardware_uart: UART0
  level: DEBUG
  logs:
    i2s_audio: DEBUG
    i2s_audio.speaker: DEBUG
    speaker: DEBUG
    component: INFO
    ethernet: INFO
    api: INFO
    api.connection: INFO
    mdns: INFO
    safe_mode: INFO

# -------------------------------------------------------------------
# NETZWERK ANBINDUNG (Ethernet only – kein WiFi nötig)
# -------------------------------------------------------------------
ethernet:
  type: IP101
  mdc_pin: GPIO31
  mdio_pin: GPIO52
  power_pin: GPIO51
  clk:
    mode: CLK_EXT_IN
    pin: GPIO50
  phy_addr: 1
  domain: ".local"

api:
  encryption:
    key: !secret encryption_key
  on_client_connected:
    - logger.log: "Home Assistant API connected!"
    - micro_wake_word.start:
    - lambda: |-
        id(va_state).publish_state("Bereit (Hey Jarvis)");
  on_client_disconnected:
    - logger.log: "Home Assistant API disconnected!"
    - voice_assistant.stop:
    - micro_wake_word.stop:
    - lambda: |-
        id(va_state).publish_state("Keine API-Verbindung");

ota:
  - platform: esphome
    password: !secret wifi_password

# -------------------------------------------------------------------
# I2C & AUDIO CODEC (ES8311)
# -------------------------------------------------------------------
i2c:
  sda: GPIO7
  scl: GPIO8
  scan: true
  id: bus_a
  frequency: 100kHz

audio_dac:
  - platform: es8311
    id: es8311_dac
    i2c_id: bus_a
    address: 0x18
    use_mclk: True
    use_microphone: True
    mic_gain: 42DB
    sample_rate: 16000
    bits_per_sample: 16bit

# -------------------------------------------------------------------
# I2S AUDIO BUS
# -------------------------------------------------------------------
i2s_audio:
  - id: i2s_bus
    i2s_mclk_pin: GPIO13
    i2s_bclk_pin: GPIO12
    i2s_lrclk_pin: GPIO10
    use_legacy: false

# -------------------------------------------------------------------
# AUDIO PIPELINE
# -------------------------------------------------------------------
speaker:
  - platform: i2s_audio
    id: i2s_speaker_out
    dac_type: external
    i2s_audio_id: i2s_bus
    i2s_dout_pin: GPIO9
    audio_dac: es8311_dac
    channel: mono
    num_channels: 1
    buffer_duration: 300ms
    sample_rate: 16000
    bits_per_sample: 16bit

  - platform: mixer
    id: main_audio_mixer
    output_speaker: i2s_speaker_out
    source_speakers:
      - id: media_spk_mixer_input
      - id: announcement_spk_mixer_input

  - platform: resampler
    id: media_spk_resampler
    output_speaker: media_spk_mixer_input

  - platform: resampler
    id: announcement_spk_resampler
    output_speaker: announcement_spk_mixer_input

# -------------------------------------------------------------------
# MEDIA PLAYER
# -------------------------------------------------------------------
media_player:
  - platform: speaker
    name: "ESP32-P4 Radio"
    id: speaker_media_player
    media_pipeline:
      speaker: media_spk_resampler
      num_channels: 1
    announcement_pipeline:
      speaker: announcement_spk_resampler
      num_channels: 1
    codec_support_enabled: true

# -------------------------------------------------------------------
# MIKROFON
# -------------------------------------------------------------------
microphone:
  - platform: i2s_audio
    id: my_mic
    i2s_audio_id: i2s_bus
    i2s_din_pin: GPIO11
    adc_type: external
    bits_per_channel: default

# -------------------------------------------------------------------
# MICRO WAKE WORD – \"Hey Jarvis\" + \"Okay Nabu\" (Debug-Modus)
# -------------------------------------------------------------------
micro_wake_word:
  models:
    - model: hey_jarvis
      probability_cutoff: 0.6
      sliding_window_size: 5
    - model: okay_nabu
      probability_cutoff: 0.5
      sliding_window_size: 5
  on_wake_word_detected:
    - logger.log:
        format: \">>> WAKE WORD erkannt! Stoppe Mic, starte VA... <<<\"
        level: WARN
    - lambda: |-
        id(va_state).publish_state(\"Wake Word erkannt!\");
    # MWW muss ZUERST stoppen → gibt Mic/I2S Bus frei
    - micro_wake_word.stop:
    - delay: 300ms
    - voice_assistant.start:

# -------------------------------------------------------------------
# VOICE ASSISTANT
# -------------------------------------------------------------------
voice_assistant:
  id: va
  microphone: my_mic
  speaker: announcement_spk_resampler
  noise_suppression_level: 2
  auto_gain: 31dBFS
  volume_multiplier: 2.0

  on_listening:
    - logger.log:
        level: WARN
        format: \"VA: Höre zu...\"
    - lambda: |-
        id(va_state).publish_state(\"Höre zu...\");

  on_stt_vad_end:
    - logger.log:
        level: WARN
        format: \"VA: Sprache erkannt, stoppe Mic für Speaker...\"
    - lambda: |-
        id(va_state).publish_state(\"Verarbeite...\");

  on_stt_end:
    - logger.log:
        level: WARN
        format: \"VA STT: %s\"
        args: ['x.c_str()']
    - lambda: |-
        id(va_state).publish_state(\"Erkannt: \" + x);

  on_tts_start:
    - logger.log:
        level: WARN
        format: \"VA TTS: %s\"
        args: ['x.c_str()']
    - lambda: |-
        id(va_state).publish_state(\"Antwort: \" + x);

  on_tts_end:
    - logger.log:
        level: WARN
        format: \"VA: TTS Wiedergabe beendet\"

  on_end:
    - logger.log:
        level: WARN
        format: \"VA: Pipeline beendet, warte auf Speaker...\"
    - script.execute: wait_and_restart_wakeword

  on_error:
    - logger.log:
        level: ERROR
        format: \"VA Fehler: %s (Code: %s)\"
        args: ['code.c_str()', 'message.c_str()']
    - lambda: |-
        id(va_state).publish_state(\"Fehler!\");
    # Nach Fehler trotzdem Wake Word neustarten
    - delay: 2s
    - micro_wake_word.start:

# -------------------------------------------------------------------
# SCRIPT: Warte bis Speaker fertig, dann Wake Word restart
# -------------------------------------------------------------------
script:
  - id: wait_and_restart_wakeword
    mode: restart
    then:
      - lambda: |-
          id(va_state).publish_state(\"Spielt Audio...\");
      # Warte bis Speaker anfängt zu spielen (max 10s)
      - wait_until:
          timeout: 10s
          condition:
            lambda: 'return id(i2s_speaker_out).is_running();'
      - logger.log:
          level: WARN
          format: \"Speaker spielt, warte auf Ende...\"
      # Warte bis Speaker fertig ist (max 60s)
      - wait_until:
          timeout: 60s
          condition:
            lambda: 'return !id(i2s_speaker_out).is_running();'
      - logger.log:
          level: WARN
          format: \"Speaker gestoppt, starte Wake Word...\"
      - delay: 500ms
      - micro_wake_word.start:
      - lambda: |-
          id(va_state).publish_state(\"Bereit (Hey Jarvis)\");

# -------------------------------------------------------------------
# STEUERUNGSELEMENTE (HOME ASSISTANT)
# -------------------------------------------------------------------
number:
  - platform: template
    name: \"Microphone Gain\"
    id: mic_gain_control
    min_value: 0
    max_value: 42
    step: 3
    unit_of_measurement: \"dB\"
    initial_value: 30
    optimistic: true
    on_value:
      - lambda: |-
          uint8_t index = (uint8_t)(x / 3.0);
          if (index > 14) index = 14; 
          uint8_t reg_val = 0x10 | index; 
          id(es8311_dac).write_byte(0x14, reg_val);
          ESP_LOGI(\"config\", \"ES8311 Mic Gain set to: %.0f dB (Reg 0x14: 0x%02X)\", x, reg_val);

  - platform: template
    name: \"Noise Suppression Level\"
    id: ns_level_control
    min_value: 0
    max_value: 4
    step: 1
    initial_value: 2
    optimistic: true
    on_value:
      - lambda: |-
          ESP_LOGI(\"config\", \"New Noise Suppression Level: %.0f\", x);

  - platform: template
    name: \"Speaker Volume\"
    id: spk_volume_control
    min_value: 0
    max_value: 100
    step: 1
    unit_of_measurement: \"%\"
    initial_value: 80
    optimistic: true
    on_value:
      - lambda: |-
          uint8_t reg_val = (uint8_t)((100.0 - x) * 1.9); 
          id(es8311_dac).write_byte(0x32, reg_val);
          ESP_LOGI(\"config\", \"Speaker Volume set to: %.0f%% (Reg 0x32: 0x%02X)\", x, reg_val);

# -------------------------------------------------------------------
# VERSTÄRKER KONTROLLE
# -------------------------------------------------------------------
switch:
  - platform: gpio
    pin: GPIO53
    name: \"Amplifier Enable\"
    id: amp_enable
    restore_mode: ALWAYS_ON

# -------------------------------------------------------------------
# MANUELLE KONTROLLEN
# -------------------------------------------------------------------
button:
  - platform: template
    name: \"Speaker Diagnostics\"
    id: speaker_diag
    icon: \"mdi:stethoscope\"
    on_press:
      - lambda: |-
          ESP_LOGW(\"diag\", \"========== DIAGNOSTICS ==========\");
          ESP_LOGW(\"diag\", \"Free Heap: %u bytes\", esp_get_free_heap_size());
          ESP_LOGW(\"diag\", \"Amp: %s\", id(amp_enable).state ? \"ON\" : \"OFF\");
          uint8_t val;
          id(es8311_dac).read_byte(0x37, &val);
          ESP_LOGW(\"diag\", \"DAC Power (0x37): 0x%02X (0x08=on)\", val);
          id(es8311_dac).read_byte(0x33, &val);
          ESP_LOGW(\"diag\", \"DAC Mute (0x33): 0x%02X (0x00=unmuted)\", val);
          ESP_LOGW(\"diag\", \"=================================\");

  - platform: template
    name: \"Play Test Sound\"
    id: play_test_tone_synth
    icon: \"mdi:volume-high\"
    on_press:
      - micro_wake_word.stop:
      - delay: 500ms
      - lambda: |-
          std::vector<uint8_t> data;
          for (int i = 0; i < 8000; i++) {
              int16_t sample = ((i / 8) % 2 == 0) ? 32000 : -32000;
              data.push_back(sample & 0xFF);
              data.push_back((sample >> 8) & 0xFF);
          }
          id(i2s_speaker_out).play(data.data(), data.size());
          ESP_LOGI(\"test\", \"Test tone played\");
      - delay: 2000ms
      - micro_wake_word.start:

# -------------------------------------------------------------------
# STATUS SENSOR
# -------------------------------------------------------------------
text_sensor:
  - platform: template
    name: \"Voice Assistant State\"
    id: va_state
    lambda: |-
      return {};
    update_interval: never
